---
title: Como construir imagens de containers Distroless e Multi Plataforma.
description: >-
  Guia prÃ¡tico sobre imagens Distroless e builds multi-plataforma: criaÃ§Ã£o com apko, anÃ¡lise de SBOM, verificaÃ§Ã£o de vulnerabilidades e troubleshooting no Kubernetes utilizando Ephemeral Container.
author: Gerson Carneiro
date: 2025-10-18 18:28:00 -0300
categories: [Containers, Docker, Kubernetes]
tags: [Containers, Docker, Kubernetes]
render_with_liquid: false
image:
  path: /commons/bg-distroless.png
  # lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
  alt: Imagem retrÃ´ futurista

---

# KRO Laboratory
This is pratical lab for testing KRO

## Why kro?
Manage any group of resources as one unit
Using kro, the Platform Team can enable Developer teams to quickly deploy and manage applications and their dependencies as one unit, handling the entire lifecycle from deployment to maintenance. The new APIs integrate seamlessly with developers' existing CD tools, preserving familiar processes and interfaces to simplify adoption.

## Collaborate
Transform Kubernetes into your unified platform configuration framework using kro. Platform, Compliance, and Security teams work together to develop APIs that standardize and streamline configurations, making it easier for Developer teams to adopt secure, compliant practices. This collaboration lets you build your organizational standards directly into the APIs, ensuring every application deployment aligns with security and compliance requirements without adding complexity for developers.

## Standardize
By creating unified APIs, you can define and enforce best practices across all environments, ensuring every application meets organizational requirements and achieving consistency across deployment environments.

## âš ï¸ Can I use this in production?

This project is in active development and not yet intended for production use. The ResourceGraphDefinition CRD and other APIs used in this project are not solidified and highly subject to change.

## Diagram to facilitate understanding KRO
In short:

KRO is an abstraction layer over Kubernetes:
- Platform teams define robust templates (RGDs).
- Devs use these templates simply, with few parameters.
- KRO transforms these into real Kubernetes resources, applied to the AWS/EKS cluster.

![](./img/diagram.jpg)

It's like having a chef (KRO) who receives simplified orders from the client (devs), but follows detailed recipes prepared by the kitchen team (platform and security). ðŸ‘©ðŸ»â€ðŸ³ ðŸ™‹ðŸ»â€â™‚ï¸

## Let's go to lab

### First update your context cluster

```shell
aws eks update-kubeconfig --region us-east-1 --name kro-lab
```

### Install kro in EKS Cluster using Helm

1. Once authenticated, install kro using the Helm chart:
Fetch the latest release version from GitHub.
```shell
export KRO_VERSION=$(curl -sL \
    https://api.github.com/repos/kro-run/kro/releases/latest | \
    jq -r '.tag_name | ltrimstr("v")'
  )
```

2. Validate KRO_VERSION populated with a version

```
echo $KRO_VERSION
```

3. Install kro using Helm

```
helm install kro oci://ghcr.io/kro-run/kro/kro \
  --namespace kro \
  --create-namespace \
  --version=${KRO_VERSION}
```

4. Get KRO template deployed resourcets:

```shell
kubectl get all -n kro

NAME                      READY   STATUS    RESTARTS   AGE
pod/kro-7784f4d6b-mrz7t   1/1     Running   0          10m

NAME                  READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/kro   1/1     1            1           10m

NAME                            DESIRED   CURRENT   READY   AGE
replicaset.apps/kro-7784f4d6b   1         1         1       10m
```

### Create KRO template to my first application

5. Creating ours Application ResourceGraphDefinition unsing Kubectl
Let's create a Resource Graph Definition.

```shell
kubectl apply -f template-app-kro/template-api-rest.yaml
```

**Explain KRO Template**:  
I'll explain bellow, the KRO template file `manifests/template-api-rest.yaml` 
`ResourceGraphDefinition`: Is principal resource to KRO, this template defines template for create group of resources for applications template for api rest `name: my-app-api-rest`, in spec, you defines schema of the kind `Application`, here you defines variables for application templates.

Further down, in the resource field, you create Kubernetes resources (namespaces, deployments, etc.) by passing a list in the format `- id: resource_name`, in this template you can create one or more resources.

In my example, we'll create `namespace`, `deployment`, `service`, and `ingress`.

```yaml
apiVersion: kro.run/v1alpha1
kind: ResourceGraphDefinition
metadata:
  name: my-app-api-rest
spec:
  schema:
    apiVersion: v1alpha1
    kind: Application
    spec:
      name: string
      image: string | default="nginx"
      namespace: string | default="default"
      ingress:
        enabled: boolean | default=false
    status:
      deploymentConditions: ${deployment.status.conditions}
      availableReplicas: ${deployment.status.availableReplicas}

  resources:
    - id: ns
      template:
        apiVersion: v1
        kind: Namespace
        ...

    - id: deployment
      template:
        apiVersion: apps/v1
        kind: Deployment
        ...

    - id: service
      template:
        apiVersion: v1
        kind: Service
        ...

    - id: ingress
      includeWhen:
        - ${schema.spec.ingress.enabled}
      template:
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        ...
```
> note: `namespace` resourece id is used by default for kro, then we use `ns`.


For more information access the file [template-api-rest.yaml](./template-app-kro/template-api-rest.yaml).

6. Inspect the ResourceGraphDefinition: Check the status of the resources created by the ResourceGraphDefinition using the kubectl command:

```
kubectl get rgd -o wide

NAME              APIVERSION   KIND          STATE    TOPOLOGICALORDER                          AGE
my-app-api-rest   v1alpha1     Application   Active   ["ns","deployment","service","ingress"]   21s
```

## Deploy first application

7. For deploy first application, run the command bellow:

```shell
kubectl apply -f template-app-user/app.yaml

application.kro.run/my-app created
```

**Explain KRO Template**:  

The template below is referencing the KRO `Application` API type, as you can see the templates are abstracted for the user, filling only the necessary variables that we defined in the `ResourceGraphDefinition`.
```yaml
apiVersion: kro.run/v1alpha1
kind: Application
metadata:
  name: my-app
spec:
  namespace: first-namespace
  name: my-awesome-app
  ingress:
    enabled: true
```

For more information access the file [template-api-rest.yaml](./template-app-user/app.yaml).

8. After deployed application, run bellow command to check:

```shell
kubectl get applications
NAME     STATE    SYNCED   AGE
my-app   ACTIVE   True     16m

```

9. Check created resources

```shell
kubectl get ns,deploy,ingress,svc,po -n first-namespace

NAME                        STATUS   AGE
namespace/default           Active   119m
namespace/first-namespace   Active   20m
namespace/kro               Active   100m
namespace/kube-node-lease   Active   119m
namespace/kube-public       Active   119m
namespace/kube-system       Active   119m

NAME                             READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/my-awesome-app   3/3     3            3           20m

NAME                                               CLASS    HOSTS   ADDRESS   PORTS   AGE
ingress.networking.k8s.io/my-awesome-app-ingress   <none>   *                 80      20m

NAME                             TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
service/my-awesome-app-service   ClusterIP   10.100.164.17   <none>        80/TCP    20m

NAME                                  READY   STATUS    RESTARTS   AGE
pod/my-awesome-app-7f4d4cfd66-6nj9k   1/1     Running   0          20m
pod/my-awesome-app-7f4d4cfd66-7vbfg   1/1     Running   0          20m
pod/my-awesome-app-7f4d4cfd66-whrwz   1/1     Running   0          20m
```

Deployment successfully completed in a simple manner, maintaining the standard baseline defined by the platform team and simplifying things for the user.